prog: VAR
##
## Ends in an error in state: 0.
##
## prog' -> . prog [ # ]
##
## The known suffix of the stack is as follows:
##
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: WHILE VAR
##
## Ends in an error in state: 1.
##
## expr -> WHILE . expr DO expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## WHILE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LPAREN VAR
##
## Ends in an error in state: 3.
##
## expr -> LPAREN . RPAREN [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> LPAREN . nonempty_list(exprseq) RPAREN [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET WHILE
##
## Ends in an error in state: 5.
##
## expr -> LET . list(dec) IN nonempty_list(exprseq) END [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## LET
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR WHILE
##
## Ends in an error in state: 6.
##
## vardec -> VAR . ID COLON ID ASSIGN expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR . ID COLON ID ASSIGN ID LBRACK expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR . ID ASSIGN expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR . ID ASSIGN ID LBRACK expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID WHILE
##
## Ends in an error in state: 7.
##
## vardec -> VAR ID . COLON ID ASSIGN expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR ID . COLON ID ASSIGN ID LBRACK expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR ID . ASSIGN expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR ID . ASSIGN ID LBRACK expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON WHILE
##
## Ends in an error in state: 8.
##
## vardec -> VAR ID COLON . ID ASSIGN expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR ID COLON . ID ASSIGN ID LBRACK expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID WHILE
##
## Ends in an error in state: 9.
##
## vardec -> VAR ID COLON ID . ASSIGN expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR ID COLON ID . ASSIGN ID LBRACK expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID ASSIGN VAR
##
## Ends in an error in state: 10.
##
## vardec -> VAR ID COLON ID ASSIGN . expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR ID COLON ID ASSIGN . ID LBRACK expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID ASSIGN ID WHILE
##
## Ends in an error in state: 12.
##
## expr -> ID . LBRACE list(fields) RBRACE [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## expr -> ID . LPAREN list(exprlist) RPAREN [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## lvalue -> ID . [ VAR TYPE TIMES PLUS OR NEQ MINUS LBRACK IN GT FUNCTION EQ DOT ASSIGN AND ]
## vardec -> VAR ID COLON ID ASSIGN ID . LBRACK expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID ASSIGN ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LPAREN VAR
##
## Ends in an error in state: 13.
##
## expr -> ID LPAREN . list(exprlist) RPAREN [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## ID LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IF VAR
##
## Ends in an error in state: 14.
##
## closedexpr -> IF . entryexpr THEN closedexpr ELSE closedexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END ELSE COMMA ]
## openexpr -> IF . entryexpr THEN expr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
## openexpr -> IF . entryexpr THEN openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
## openexpr -> IF . entryexpr THEN closedexpr ELSE openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## IF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID OF
##
## Ends in an error in state: 15.
##
## expr -> ID . LBRACE list(fields) RBRACE [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> ID . LPAREN list(exprlist) RPAREN [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## lvalue -> ID . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET LBRACK INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE WHILE
##
## Ends in an error in state: 16.
##
## expr -> ID LBRACE . list(fields) RBRACE [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## ID LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID WHILE
##
## Ends in an error in state: 17.
##
## field -> ID . EQ expr [ RBRACE ID COMMA ]
## field -> ID . EQ ID LBRACK expr RBRACK OF expr [ RBRACE ID COMMA ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ VAR
##
## Ends in an error in state: 18.
##
## field -> ID EQ . expr [ RBRACE ID COMMA ]
## field -> ID EQ . ID LBRACK expr RBRACK OF expr [ RBRACE ID COMMA ]
##
## The known suffix of the stack is as follows:
## ID EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ ID WHILE
##
## Ends in an error in state: 19.
##
## expr -> ID . LBRACE list(fields) RBRACE [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## expr -> ID . LPAREN list(exprlist) RPAREN [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## field -> ID EQ ID . LBRACK expr RBRACK OF expr [ RBRACE ID COMMA ]
## lvalue -> ID . [ TIMES RBRACE PLUS OR NEQ MINUS LBRACK ID GT EQ DOT COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## ID EQ ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ ID LBRACK VAR
##
## Ends in an error in state: 20.
##
## field -> ID EQ ID LBRACK . expr RBRACK OF expr [ RBRACE ID COMMA ]
##
## The known suffix of the stack is as follows:
## ID EQ ID LBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID DOT ID OF
##
## Ends in an error in state: 21.
##
## expr -> lvalue . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> lvalue . ASSIGN expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> lvalue . ASSIGN ID LBRACK expr RBRACK OF expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## lvalue -> lvalue . DOT ID [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET LBRACK INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
## lvalue -> lvalue . LBRACK expr RBRACK [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET LBRACK INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## lvalue
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACK VAR
##
## Ends in an error in state: 22.
##
## lvalue -> lvalue LBRACK . expr RBRACK [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET LBRACK INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## lvalue LBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACK INT RBRACE
##
## Ends in an error in state: 23.
##
## binop -> expr . EQ expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . NEQ expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . TIMES expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . MINUS expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . PLUS expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . GT expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . AND expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . OR expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## lvalue -> lvalue LBRACK expr . RBRACK [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET LBRACK INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## lvalue LBRACK expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: INT TIMES VAR
##
## Ends in an error in state: 24.
##
## binop -> expr TIMES . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr TIMES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: INT PLUS VAR
##
## Ends in an error in state: 29.
##
## binop -> expr PLUS . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr PLUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: INT PLUS INT OF
##
## Ends in an error in state: 30.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr PLUS expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr PLUS expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: INT OR VAR
##
## Ends in an error in state: 31.
##
## expr -> expr OR . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr OR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: INT OR INT OF
##
## Ends in an error in state: 32.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr OR expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr OR expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: INT NEQ VAR
##
## Ends in an error in state: 33.
##
## binop -> expr NEQ . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr NEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: INT NEQ INT OF
##
## Ends in an error in state: 34.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr NEQ expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr NEQ expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: INT MINUS VAR
##
## Ends in an error in state: 35.
##
## binop -> expr MINUS . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr MINUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: INT MINUS INT OF
##
## Ends in an error in state: 36.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr MINUS expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr MINUS expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: INT GT VAR
##
## Ends in an error in state: 37.
##
## binop -> expr GT . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr GT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: INT GT INT OF
##
## Ends in an error in state: 38.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr GT expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr GT expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: INT EQ VAR
##
## Ends in an error in state: 39.
##
## binop -> expr EQ . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: INT EQ INT OF
##
## Ends in an error in state: 40.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr EQ expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr EQ expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: INT AND VAR
##
## Ends in an error in state: 41.
##
## expr -> expr AND . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr AND
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: INT AND INT OF
##
## Ends in an error in state: 42.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr AND expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr AND expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID DOT WHILE
##
## Ends in an error in state: 43.
##
## lvalue -> lvalue DOT . ID [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET LBRACK INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## lvalue DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID ASSIGN VAR
##
## Ends in an error in state: 45.
##
## expr -> lvalue ASSIGN . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> lvalue ASSIGN . ID LBRACK expr RBRACK OF expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## lvalue ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID ASSIGN ID OF
##
## Ends in an error in state: 46.
##
## expr -> lvalue ASSIGN ID . LBRACK expr RBRACK OF expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> ID . LBRACE list(fields) RBRACE [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> ID . LPAREN list(exprlist) RPAREN [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## lvalue -> ID . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET LBRACK INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## lvalue ASSIGN ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID ASSIGN ID LBRACK VAR
##
## Ends in an error in state: 47.
##
## expr -> lvalue ASSIGN ID LBRACK . expr RBRACK OF expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## lvalue ASSIGN ID LBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID ASSIGN ID LBRACK INT RBRACE
##
## Ends in an error in state: 48.
##
## binop -> expr . EQ expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . NEQ expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . TIMES expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . MINUS expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . PLUS expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . GT expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . AND expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . OR expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> lvalue ASSIGN ID LBRACK expr . RBRACK OF expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## lvalue ASSIGN ID LBRACK expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID ASSIGN ID LBRACK INT RBRACK WHILE
##
## Ends in an error in state: 49.
##
## expr -> lvalue ASSIGN ID LBRACK expr RBRACK . OF expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## lvalue ASSIGN ID LBRACK expr RBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID ASSIGN ID LBRACK INT RBRACK OF VAR
##
## Ends in an error in state: 50.
##
## expr -> lvalue ASSIGN ID LBRACK expr RBRACK OF . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## lvalue ASSIGN ID LBRACK expr RBRACK OF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID ASSIGN ID LBRACK INT RBRACK OF INT OF
##
## Ends in an error in state: 51.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> lvalue ASSIGN ID LBRACK expr RBRACK OF expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## lvalue ASSIGN ID LBRACK expr RBRACK OF expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID ASSIGN INT OF
##
## Ends in an error in state: 52.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> lvalue ASSIGN expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## lvalue ASSIGN expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ ID LBRACK INT RBRACE
##
## Ends in an error in state: 53.
##
## binop -> expr . EQ expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . NEQ expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . TIMES expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . MINUS expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . PLUS expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . GT expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . AND expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . OR expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## field -> ID EQ ID LBRACK expr . RBRACK OF expr [ RBRACE ID COMMA ]
##
## The known suffix of the stack is as follows:
## ID EQ ID LBRACK expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ ID LBRACK INT RBRACK WHILE
##
## Ends in an error in state: 54.
##
## field -> ID EQ ID LBRACK expr RBRACK . OF expr [ RBRACE ID COMMA ]
##
## The known suffix of the stack is as follows:
## ID EQ ID LBRACK expr RBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ ID LBRACK INT RBRACK OF VAR
##
## Ends in an error in state: 55.
##
## field -> ID EQ ID LBRACK expr RBRACK OF . expr [ RBRACE ID COMMA ]
##
## The known suffix of the stack is as follows:
## ID EQ ID LBRACK expr RBRACK OF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ ID LBRACK INT RBRACK OF INT WHILE
##
## Ends in an error in state: 56.
##
## binop -> expr . EQ expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . NEQ expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . TIMES expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . MINUS expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . PLUS expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . GT expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## expr -> expr . AND expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## expr -> expr . OR expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## field -> ID EQ ID LBRACK expr RBRACK OF expr . [ RBRACE ID COMMA ]
##
## The known suffix of the stack is as follows:
## ID EQ ID LBRACK expr RBRACK OF expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ INT WHILE
##
## Ends in an error in state: 57.
##
## binop -> expr . EQ expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . NEQ expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . TIMES expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . MINUS expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . PLUS expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . GT expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## expr -> expr . AND expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## expr -> expr . OR expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## field -> ID EQ expr . [ RBRACE ID COMMA ]
##
## The known suffix of the stack is as follows:
## ID EQ expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ INT COMMA WHILE
##
## Ends in an error in state: 60.
##
## list(fields) -> fields . list(fields) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## fields
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FOR WHILE
##
## Ends in an error in state: 64.
##
## openexpr -> FOR . ID ASSIGN expr TO expr DO entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FOR ID WHILE
##
## Ends in an error in state: 65.
##
## openexpr -> FOR ID . ASSIGN expr TO expr DO entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FOR ID ASSIGN VAR
##
## Ends in an error in state: 66.
##
## openexpr -> FOR ID ASSIGN . expr TO expr DO entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FOR ID ASSIGN INT RBRACE
##
## Ends in an error in state: 67.
##
## binop -> expr . EQ expr [ TO TIMES PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . NEQ expr [ TO TIMES PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . TIMES expr [ TO TIMES PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . MINUS expr [ TO TIMES PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . PLUS expr [ TO TIMES PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . GT expr [ TO TIMES PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . AND expr [ TO TIMES PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . OR expr [ TO TIMES PLUS OR NEQ MINUS GT EQ AND ]
## openexpr -> FOR ID ASSIGN expr . TO expr DO entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FOR ID ASSIGN INT TO VAR
##
## Ends in an error in state: 68.
##
## openexpr -> FOR ID ASSIGN expr TO . expr DO entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN expr TO
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FOR ID ASSIGN INT TO INT RBRACE
##
## Ends in an error in state: 69.
##
## binop -> expr . EQ expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## binop -> expr . NEQ expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## binop -> expr . TIMES expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## binop -> expr . MINUS expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## binop -> expr . PLUS expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## binop -> expr . GT expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## expr -> expr . AND expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## expr -> expr . OR expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## openexpr -> FOR ID ASSIGN expr TO expr . DO entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN expr TO expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FOR ID ASSIGN INT TO INT DO VAR
##
## Ends in an error in state: 70.
##
## openexpr -> FOR ID ASSIGN expr TO expr DO . entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN expr TO expr DO
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: INT RBRACE
##
## Ends in an error in state: 72.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## closedexpr -> expr . [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END ELSE COMMA ]
## expr -> expr . AND expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IF INT ID
##
## Ends in an error in state: 75.
##
## closedexpr -> IF entryexpr . THEN closedexpr ELSE closedexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END ELSE COMMA ]
## openexpr -> IF entryexpr . THEN expr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
## openexpr -> IF entryexpr . THEN openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
## openexpr -> IF entryexpr . THEN closedexpr ELSE openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## IF entryexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 72, spurious reduction of production closedexpr -> expr
## In state 74, spurious reduction of production entryexpr -> closedexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IF INT THEN VAR
##
## Ends in an error in state: 76.
##
## closedexpr -> IF entryexpr THEN . closedexpr ELSE closedexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END ELSE COMMA ]
## openexpr -> IF entryexpr THEN . expr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
## openexpr -> IF entryexpr THEN . openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
## openexpr -> IF entryexpr THEN . closedexpr ELSE openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## IF entryexpr THEN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IF INT THEN INT RBRACE
##
## Ends in an error in state: 78.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## closedexpr -> expr . [ ELSE ]
## expr -> expr . AND expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## openexpr -> IF entryexpr THEN expr . [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## IF entryexpr THEN expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IF INT THEN IF INT THEN INT ELSE INT ID
##
## Ends in an error in state: 79.
##
## closedexpr -> IF entryexpr THEN closedexpr . ELSE closedexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END ELSE COMMA ]
## openexpr -> IF entryexpr THEN closedexpr . ELSE openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## IF entryexpr THEN closedexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 72, spurious reduction of production closedexpr -> expr
## In state 82, spurious reduction of production closedexpr -> IF entryexpr THEN closedexpr ELSE closedexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IF INT THEN INT ELSE VAR
##
## Ends in an error in state: 80.
##
## closedexpr -> IF entryexpr THEN closedexpr ELSE . closedexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END ELSE COMMA ]
## openexpr -> IF entryexpr THEN closedexpr ELSE . openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## IF entryexpr THEN closedexpr ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LPAREN INT COMMA VAR
##
## Ends in an error in state: 85.
##
## list(exprlist) -> exprlist . list(exprlist) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## exprlist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LPAREN INT ELSE
##
## Ends in an error in state: 87.
##
## exprlist -> entryexpr . [ WHILE STRING RPAREN LPAREN LET INT IF ID FOR ]
## exprlist -> entryexpr . COMMA [ WHILE STRING RPAREN LPAREN LET INT IF ID FOR ]
##
## The known suffix of the stack is as follows:
## entryexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 72, spurious reduction of production closedexpr -> expr
## In state 74, spurious reduction of production entryexpr -> closedexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID ASSIGN ID LBRACK VAR
##
## Ends in an error in state: 89.
##
## vardec -> VAR ID COLON ID ASSIGN ID LBRACK . expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID ASSIGN ID LBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID ASSIGN ID LBRACK INT RBRACE
##
## Ends in an error in state: 90.
##
## binop -> expr . EQ expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . NEQ expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . TIMES expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . MINUS expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . PLUS expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . GT expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . AND expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . OR expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## vardec -> VAR ID COLON ID ASSIGN ID LBRACK expr . RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID ASSIGN ID LBRACK expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID ASSIGN ID LBRACK INT RBRACK WHILE
##
## Ends in an error in state: 91.
##
## vardec -> VAR ID COLON ID ASSIGN ID LBRACK expr RBRACK . OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID ASSIGN ID LBRACK expr RBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID ASSIGN ID LBRACK INT RBRACK OF VAR
##
## Ends in an error in state: 92.
##
## vardec -> VAR ID COLON ID ASSIGN ID LBRACK expr RBRACK OF . expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID ASSIGN ID LBRACK expr RBRACK OF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID ASSIGN ID LBRACK INT RBRACK OF INT RBRACE
##
## Ends in an error in state: 93.
##
## binop -> expr . EQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . NEQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . TIMES expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . MINUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . PLUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . GT expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## expr -> expr . AND expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## expr -> expr . OR expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## vardec -> VAR ID COLON ID ASSIGN ID LBRACK expr RBRACK OF expr . [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID ASSIGN ID LBRACK expr RBRACK OF expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID ASSIGN INT RBRACE
##
## Ends in an error in state: 94.
##
## binop -> expr . EQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . NEQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . TIMES expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . MINUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . PLUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . GT expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## expr -> expr . AND expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## expr -> expr . OR expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## vardec -> VAR ID COLON ID ASSIGN expr . [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID ASSIGN expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID ASSIGN VAR
##
## Ends in an error in state: 95.
##
## vardec -> VAR ID ASSIGN . expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR ID ASSIGN . ID LBRACK expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID ASSIGN ID WHILE
##
## Ends in an error in state: 96.
##
## expr -> ID . LBRACE list(fields) RBRACE [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## expr -> ID . LPAREN list(exprlist) RPAREN [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## lvalue -> ID . [ VAR TYPE TIMES PLUS OR NEQ MINUS LBRACK IN GT FUNCTION EQ DOT ASSIGN AND ]
## vardec -> VAR ID ASSIGN ID . LBRACK expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID ASSIGN ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID ASSIGN ID LBRACK VAR
##
## Ends in an error in state: 97.
##
## vardec -> VAR ID ASSIGN ID LBRACK . expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID ASSIGN ID LBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID ASSIGN ID LBRACK INT RBRACE
##
## Ends in an error in state: 98.
##
## binop -> expr . EQ expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . NEQ expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . TIMES expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . MINUS expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . PLUS expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . GT expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . AND expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . OR expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## vardec -> VAR ID ASSIGN ID LBRACK expr . RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID ASSIGN ID LBRACK expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID ASSIGN ID LBRACK INT RBRACK WHILE
##
## Ends in an error in state: 99.
##
## vardec -> VAR ID ASSIGN ID LBRACK expr RBRACK . OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID ASSIGN ID LBRACK expr RBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID ASSIGN ID LBRACK INT RBRACK OF VAR
##
## Ends in an error in state: 100.
##
## vardec -> VAR ID ASSIGN ID LBRACK expr RBRACK OF . expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID ASSIGN ID LBRACK expr RBRACK OF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID ASSIGN ID LBRACK INT RBRACK OF INT RBRACE
##
## Ends in an error in state: 101.
##
## binop -> expr . EQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . NEQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . TIMES expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . MINUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . PLUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . GT expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## expr -> expr . AND expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## expr -> expr . OR expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## vardec -> VAR ID ASSIGN ID LBRACK expr RBRACK OF expr . [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID ASSIGN ID LBRACK expr RBRACK OF expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID ASSIGN INT RBRACE
##
## Ends in an error in state: 102.
##
## binop -> expr . EQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . NEQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . TIMES expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . MINUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . PLUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . GT expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## expr -> expr . AND expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## expr -> expr . OR expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## vardec -> VAR ID ASSIGN expr . [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID ASSIGN expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE WHILE
##
## Ends in an error in state: 103.
##
## tydecs -> TYPE . nonempty_list(tydec) [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## TYPE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID WHILE
##
## Ends in an error in state: 104.
##
## tydec -> ID . EQ ID [ VAR TYPE IN ID FUNCTION ]
## tydec -> ID . EQ ARRAY OF ID [ VAR TYPE IN ID FUNCTION ]
## tydec -> ID . EQ LBRACE loption(separated_nonempty_list(COMMA,tyfield)) RBRACE [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID EQ WHILE
##
## Ends in an error in state: 105.
##
## tydec -> ID EQ . ID [ VAR TYPE IN ID FUNCTION ]
## tydec -> ID EQ . ARRAY OF ID [ VAR TYPE IN ID FUNCTION ]
## tydec -> ID EQ . LBRACE loption(separated_nonempty_list(COMMA,tyfield)) RBRACE [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID EQ LBRACE WHILE
##
## Ends in an error in state: 106.
##
## tydec -> ID EQ LBRACE . loption(separated_nonempty_list(COMMA,tyfield)) RBRACE [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID EQ LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN ID WHILE
##
## Ends in an error in state: 107.
##
## tyfield -> ID . COLON ID [ RPAREN RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN ID COLON WHILE
##
## Ends in an error in state: 108.
##
## tyfield -> ID COLON . ID [ RPAREN RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## ID COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN ID COLON ID WHILE
##
## Ends in an error in state: 110.
##
## separated_nonempty_list(COMMA,tyfield) -> tyfield . [ RPAREN RBRACE ]
## separated_nonempty_list(COMMA,tyfield) -> tyfield . COMMA separated_nonempty_list(COMMA,tyfield) [ RPAREN RBRACE ]
##
## The known suffix of the stack is as follows:
## tyfield
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN ID COLON ID COMMA WHILE
##
## Ends in an error in state: 111.
##
## separated_nonempty_list(COMMA,tyfield) -> tyfield COMMA . separated_nonempty_list(COMMA,tyfield) [ RPAREN RBRACE ]
##
## The known suffix of the stack is as follows:
## tyfield COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID EQ LBRACE ID COLON ID RPAREN
##
## Ends in an error in state: 114.
##
## tydec -> ID EQ LBRACE loption(separated_nonempty_list(COMMA,tyfield)) . RBRACE [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID EQ LBRACE loption(separated_nonempty_list(COMMA,tyfield))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 110, spurious reduction of production separated_nonempty_list(COMMA,tyfield) -> tyfield
## In state 113, spurious reduction of production loption(separated_nonempty_list(COMMA,tyfield)) -> separated_nonempty_list(COMMA,tyfield)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID EQ ARRAY WHILE
##
## Ends in an error in state: 117.
##
## tydec -> ID EQ ARRAY . OF ID [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID EQ ARRAY
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID EQ ARRAY OF WHILE
##
## Ends in an error in state: 118.
##
## tydec -> ID EQ ARRAY OF . ID [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID EQ ARRAY OF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID EQ ID WHILE
##
## Ends in an error in state: 120.
##
## nonempty_list(tydec) -> tydec . [ VAR TYPE IN FUNCTION ]
## nonempty_list(tydec) -> tydec . nonempty_list(tydec) [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## tydec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION WHILE
##
## Ends in an error in state: 123.
##
## fundecs -> FUNCTION . nonempty_list(fundec) [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## FUNCTION
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID WHILE
##
## Ends in an error in state: 124.
##
## fundec -> ID . LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt) EQ entryexpr [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN WHILE
##
## Ends in an error in state: 125.
##
## fundec -> ID LPAREN . loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt) EQ entryexpr [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN ID COLON ID RBRACE
##
## Ends in an error in state: 126.
##
## fundec -> ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) . RPAREN option(resultopt) EQ entryexpr [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID LPAREN loption(separated_nonempty_list(COMMA,tyfield))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 110, spurious reduction of production separated_nonempty_list(COMMA,tyfield) -> tyfield
## In state 113, spurious reduction of production loption(separated_nonempty_list(COMMA,tyfield)) -> separated_nonempty_list(COMMA,tyfield)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN RPAREN WHILE
##
## Ends in an error in state: 127.
##
## fundec -> ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN . option(resultopt) EQ entryexpr [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN RPAREN COLON WHILE
##
## Ends in an error in state: 128.
##
## resultopt -> COLON . ID [ EQ ]
##
## The known suffix of the stack is as follows:
## COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN RPAREN COLON ID WHILE
##
## Ends in an error in state: 131.
##
## fundec -> ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt) . EQ entryexpr [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN RPAREN EQ VAR
##
## Ends in an error in state: 132.
##
## fundec -> ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt) EQ . entryexpr [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt) EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN RPAREN EQ INT COMMA
##
## Ends in an error in state: 135.
##
## nonempty_list(fundec) -> fundec . [ VAR TYPE IN FUNCTION ]
## nonempty_list(fundec) -> fundec . nonempty_list(fundec) [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## fundec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 72, spurious reduction of production closedexpr -> expr
## In state 74, spurious reduction of production entryexpr -> closedexpr
## In state 133, spurious reduction of production fundec -> ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt) EQ entryexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET IN VAR
##
## Ends in an error in state: 140.
##
## expr -> LET list(dec) IN . nonempty_list(exprseq) END [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## LET list(dec) IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET IN INT RPAREN
##
## Ends in an error in state: 141.
##
## expr -> LET list(dec) IN nonempty_list(exprseq) . END [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## LET list(dec) IN nonempty_list(exprseq)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 72, spurious reduction of production closedexpr -> expr
## In state 74, spurious reduction of production entryexpr -> closedexpr
## In state 145, spurious reduction of production exprseq -> entryexpr
## In state 143, spurious reduction of production nonempty_list(exprseq) -> exprseq
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LPAREN INT SEMICOLON VAR
##
## Ends in an error in state: 143.
##
## nonempty_list(exprseq) -> exprseq . [ RPAREN END ]
## nonempty_list(exprseq) -> exprseq . nonempty_list(exprseq) [ RPAREN END ]
##
## The known suffix of the stack is as follows:
## exprseq
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LPAREN INT COMMA
##
## Ends in an error in state: 145.
##
## exprseq -> entryexpr . [ WHILE STRING RPAREN LPAREN LET INT IF ID FOR END ]
## exprseq -> entryexpr . SEMICOLON [ WHILE STRING RPAREN LPAREN LET INT IF ID FOR END ]
##
## The known suffix of the stack is as follows:
## entryexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 72, spurious reduction of production closedexpr -> expr
## In state 74, spurious reduction of production entryexpr -> closedexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LPAREN INT END
##
## Ends in an error in state: 150.
##
## expr -> LPAREN nonempty_list(exprseq) . RPAREN [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## LPAREN nonempty_list(exprseq)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 72, spurious reduction of production closedexpr -> expr
## In state 74, spurious reduction of production entryexpr -> closedexpr
## In state 145, spurious reduction of production exprseq -> entryexpr
## In state 143, spurious reduction of production nonempty_list(exprseq) -> exprseq
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: WHILE INT RBRACE
##
## Ends in an error in state: 152.
##
## binop -> expr . EQ expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## binop -> expr . NEQ expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## binop -> expr . TIMES expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## binop -> expr . MINUS expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## binop -> expr . PLUS expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## binop -> expr . GT expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## expr -> expr . AND expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## expr -> expr . OR expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## expr -> WHILE expr . DO expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## WHILE expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: WHILE INT DO VAR
##
## Ends in an error in state: 153.
##
## expr -> WHILE expr DO . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## WHILE expr DO
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: WHILE INT DO INT OF
##
## Ends in an error in state: 154.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> WHILE expr DO expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## WHILE expr DO expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: INT ID
##
## Ends in an error in state: 157.
##
## prog -> entryexpr . EOF [ # ]
##
## The known suffix of the stack is as follows:
## entryexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 72, spurious reduction of production closedexpr -> expr
## In state 74, spurious reduction of production entryexpr -> closedexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

