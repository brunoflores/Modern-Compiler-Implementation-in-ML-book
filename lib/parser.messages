prog: FOR ID ASSIGN STRING TO STRING DO VAR
##
## Ends in an error in state: 70.
##
## openexpr -> FOR ID ASSIGN expr TO expr DO . entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN expr TO expr DO
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FOR ID ASSIGN STRING TO STRING WHILE
##
## Ends in an error in state: 69.
##
## binop -> expr . EQ expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## binop -> expr . NEQ expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## binop -> expr . TIMES expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## binop -> expr . MINUS expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## binop -> expr . PLUS expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## binop -> expr . GT expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## expr -> expr . AND expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## expr -> expr . OR expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## openexpr -> FOR ID ASSIGN expr TO expr . DO entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN expr TO expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FOR ID ASSIGN STRING TO VAR
##
## Ends in an error in state: 68.
##
## openexpr -> FOR ID ASSIGN expr TO . expr DO entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN expr TO
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FOR ID ASSIGN STRING WHILE
##
## Ends in an error in state: 67.
##
## binop -> expr . EQ expr [ TO TIMES PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . NEQ expr [ TO TIMES PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . TIMES expr [ TO TIMES PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . MINUS expr [ TO TIMES PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . PLUS expr [ TO TIMES PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . GT expr [ TO TIMES PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . AND expr [ TO TIMES PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . OR expr [ TO TIMES PLUS OR NEQ MINUS GT EQ AND ]
## openexpr -> FOR ID ASSIGN expr . TO expr DO entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FOR ID ASSIGN VAR
##
## Ends in an error in state: 66.
##
## openexpr -> FOR ID ASSIGN . expr TO expr DO entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FOR ID WHILE
##
## Ends in an error in state: 65.
##
## openexpr -> FOR ID . ASSIGN expr TO expr DO entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FOR WHILE
##
## Ends in an error in state: 64.
##
## openexpr -> FOR . ID ASSIGN expr TO expr DO entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID ASSIGN ID LBRACK STRING RBRACK OF STRING OF
##
## Ends in an error in state: 51.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> lvalue ASSIGN ID LBRACK expr RBRACK OF expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## lvalue ASSIGN ID LBRACK expr RBRACK OF expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID ASSIGN ID LBRACK STRING RBRACK OF VAR
##
## Ends in an error in state: 50.
##
## expr -> lvalue ASSIGN ID LBRACK expr RBRACK OF . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## lvalue ASSIGN ID LBRACK expr RBRACK OF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID ASSIGN ID LBRACK STRING RBRACK WHILE
##
## Ends in an error in state: 49.
##
## expr -> lvalue ASSIGN ID LBRACK expr RBRACK . OF expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## lvalue ASSIGN ID LBRACK expr RBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID ASSIGN ID LBRACK STRING WHILE
##
## Ends in an error in state: 48.
##
## binop -> expr . EQ expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . NEQ expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . TIMES expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . MINUS expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . PLUS expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . GT expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . AND expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . OR expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> lvalue ASSIGN ID LBRACK expr . RBRACK OF expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## lvalue ASSIGN ID LBRACK expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID ASSIGN ID LBRACK VAR
##
## Ends in an error in state: 47.
##
## expr -> lvalue ASSIGN ID LBRACK . expr RBRACK OF expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## lvalue ASSIGN ID LBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID ASSIGN ID OF
##
## Ends in an error in state: 46.
##
## expr -> lvalue ASSIGN ID . LBRACK expr RBRACK OF expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> ID . LBRACE list(fields) RBRACE [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> ID . LPAREN list(exprlist) RPAREN [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## lvalue -> ID . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET LBRACK INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## lvalue ASSIGN ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID ASSIGN STRING OF
##
## Ends in an error in state: 52.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> lvalue ASSIGN expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## lvalue ASSIGN expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID ASSIGN VAR
##
## Ends in an error in state: 45.
##
## expr -> lvalue ASSIGN . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> lvalue ASSIGN . ID LBRACK expr RBRACK OF expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## lvalue ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID DOT ID OF
##
## Ends in an error in state: 21.
##
## expr -> lvalue . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> lvalue . ASSIGN expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> lvalue . ASSIGN ID LBRACK expr RBRACK OF expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## lvalue -> lvalue . DOT ID [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET LBRACK INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
## lvalue -> lvalue . LBRACK expr RBRACK [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET LBRACK INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## lvalue
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID DOT WHILE
##
## Ends in an error in state: 43.
##
## lvalue -> lvalue DOT . ID [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET LBRACK INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## lvalue DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ ID COMMA WHILE
##
## Ends in an error in state: 60.
##
## list(fields) -> fields . list(fields) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## fields
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ ID LBRACK STRING RBRACK OF STRING WHILE
##
## Ends in an error in state: 56.
##
## binop -> expr . EQ expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . NEQ expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . TIMES expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . MINUS expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . PLUS expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . GT expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## expr -> expr . AND expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## expr -> expr . OR expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## field -> ID EQ ID LBRACK expr RBRACK OF expr . [ RBRACE ID COMMA ]
##
## The known suffix of the stack is as follows:
## ID EQ ID LBRACK expr RBRACK OF expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ ID LBRACK STRING RBRACK OF VAR
##
## Ends in an error in state: 55.
##
## field -> ID EQ ID LBRACK expr RBRACK OF . expr [ RBRACE ID COMMA ]
##
## The known suffix of the stack is as follows:
## ID EQ ID LBRACK expr RBRACK OF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ ID LBRACK STRING RBRACK WHILE
##
## Ends in an error in state: 54.
##
## field -> ID EQ ID LBRACK expr RBRACK . OF expr [ RBRACE ID COMMA ]
##
## The known suffix of the stack is as follows:
## ID EQ ID LBRACK expr RBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ ID LBRACK STRING WHILE
##
## Ends in an error in state: 53.
##
## binop -> expr . EQ expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . NEQ expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . TIMES expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . MINUS expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . PLUS expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . GT expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . AND expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . OR expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## field -> ID EQ ID LBRACK expr . RBRACK OF expr [ RBRACE ID COMMA ]
##
## The known suffix of the stack is as follows:
## ID EQ ID LBRACK expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ ID LBRACK VAR
##
## Ends in an error in state: 20.
##
## field -> ID EQ ID LBRACK . expr RBRACK OF expr [ RBRACE ID COMMA ]
##
## The known suffix of the stack is as follows:
## ID EQ ID LBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ ID WHILE
##
## Ends in an error in state: 19.
##
## expr -> ID . LBRACE list(fields) RBRACE [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## expr -> ID . LPAREN list(exprlist) RPAREN [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## field -> ID EQ ID . LBRACK expr RBRACK OF expr [ RBRACE ID COMMA ]
## lvalue -> ID . [ TIMES RBRACE PLUS OR NEQ MINUS LBRACK ID GT EQ DOT COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## ID EQ ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ STRING WHILE
##
## Ends in an error in state: 57.
##
## binop -> expr . EQ expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . NEQ expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . TIMES expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . MINUS expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . PLUS expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . GT expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## expr -> expr . AND expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## expr -> expr . OR expr [ TIMES RBRACE PLUS OR NEQ MINUS ID GT EQ COMMA AND ]
## field -> ID EQ expr . [ RBRACE ID COMMA ]
##
## The known suffix of the stack is as follows:
## ID EQ expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ VAR
##
## Ends in an error in state: 18.
##
## field -> ID EQ . expr [ RBRACE ID COMMA ]
## field -> ID EQ . ID LBRACK expr RBRACK OF expr [ RBRACE ID COMMA ]
##
## The known suffix of the stack is as follows:
## ID EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID WHILE
##
## Ends in an error in state: 17.
##
## field -> ID . EQ expr [ RBRACE ID COMMA ]
## field -> ID . EQ ID LBRACK expr RBRACK OF expr [ RBRACE ID COMMA ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE WHILE
##
## Ends in an error in state: 16.
##
## expr -> ID LBRACE . list(fields) RBRACE [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## ID LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACK STRING WHILE
##
## Ends in an error in state: 23.
##
## binop -> expr . EQ expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . NEQ expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . TIMES expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . MINUS expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . PLUS expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . GT expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . AND expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . OR expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## lvalue -> lvalue LBRACK expr . RBRACK [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET LBRACK INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## lvalue LBRACK expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACK VAR
##
## Ends in an error in state: 22.
##
## lvalue -> lvalue LBRACK . expr RBRACK [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET LBRACK INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## lvalue LBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LPAREN STRING COMMA VAR
##
## Ends in an error in state: 85.
##
## list(exprlist) -> exprlist . list(exprlist) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## exprlist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LPAREN STRING VAR
##
## Ends in an error in state: 87.
##
## exprlist -> entryexpr . [ WHILE STRING RPAREN LPAREN LET INT IF ID FOR ]
## exprlist -> entryexpr . COMMA [ WHILE STRING RPAREN LPAREN LET INT IF ID FOR ]
##
## The known suffix of the stack is as follows:
## entryexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 72, spurious reduction of production closedexpr -> expr
## In state 74, spurious reduction of production entryexpr -> closedexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LPAREN VAR
##
## Ends in an error in state: 13.
##
## expr -> ID LPAREN . list(exprlist) RPAREN [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## ID LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID OF
##
## Ends in an error in state: 15.
##
## expr -> ID . LBRACE list(fields) RBRACE [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> ID . LPAREN list(exprlist) RPAREN [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## lvalue -> ID . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET LBRACK INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IF STRING THEN IF ID THEN ID ELSE ID WHILE
##
## Ends in an error in state: 79.
##
## closedexpr -> IF entryexpr THEN closedexpr . ELSE closedexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END ELSE COMMA ]
## openexpr -> IF entryexpr THEN closedexpr . ELSE openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## IF entryexpr THEN closedexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 15, spurious reduction of production lvalue -> ID
## In state 21, spurious reduction of production expr -> lvalue
## In state 72, spurious reduction of production closedexpr -> expr
## In state 82, spurious reduction of production closedexpr -> IF entryexpr THEN closedexpr ELSE closedexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IF STRING THEN STRING ELSE VAR
##
## Ends in an error in state: 80.
##
## closedexpr -> IF entryexpr THEN closedexpr ELSE . closedexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END ELSE COMMA ]
## openexpr -> IF entryexpr THEN closedexpr ELSE . openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## IF entryexpr THEN closedexpr ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IF STRING THEN STRING TO
##
## Ends in an error in state: 78.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## closedexpr -> expr . [ ELSE ]
## expr -> expr . AND expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## openexpr -> IF entryexpr THEN expr . [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## IF entryexpr THEN expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IF STRING THEN VAR
##
## Ends in an error in state: 76.
##
## closedexpr -> IF entryexpr THEN . closedexpr ELSE closedexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END ELSE COMMA ]
## openexpr -> IF entryexpr THEN . expr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
## openexpr -> IF entryexpr THEN . openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
## openexpr -> IF entryexpr THEN . closedexpr ELSE openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## IF entryexpr THEN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IF STRING WHILE
##
## Ends in an error in state: 75.
##
## closedexpr -> IF entryexpr . THEN closedexpr ELSE closedexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END ELSE COMMA ]
## openexpr -> IF entryexpr . THEN expr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
## openexpr -> IF entryexpr . THEN openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
## openexpr -> IF entryexpr . THEN closedexpr ELSE openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## IF entryexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 72, spurious reduction of production closedexpr -> expr
## In state 74, spurious reduction of production entryexpr -> closedexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IF VAR
##
## Ends in an error in state: 14.
##
## closedexpr -> IF . entryexpr THEN closedexpr ELSE closedexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END ELSE COMMA ]
## openexpr -> IF . entryexpr THEN expr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
## openexpr -> IF . entryexpr THEN openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
## openexpr -> IF . entryexpr THEN closedexpr ELSE openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## IF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN ID COLON ID COMMA WHILE
##
## Ends in an error in state: 111.
##
## separated_nonempty_list(COMMA,tyfield) -> tyfield COMMA . separated_nonempty_list(COMMA,tyfield) [ RPAREN RBRACE ]
##
## The known suffix of the stack is as follows:
## tyfield COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN ID COLON ID RBRACE
##
## Ends in an error in state: 126.
##
## fundec -> ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) . RPAREN option(resultopt) EQ entryexpr [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID LPAREN loption(separated_nonempty_list(COMMA,tyfield))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 110, spurious reduction of production separated_nonempty_list(COMMA,tyfield) -> tyfield
## In state 113, spurious reduction of production loption(separated_nonempty_list(COMMA,tyfield)) -> separated_nonempty_list(COMMA,tyfield)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN ID COLON ID WHILE
##
## Ends in an error in state: 110.
##
## separated_nonempty_list(COMMA,tyfield) -> tyfield . [ RPAREN RBRACE ]
## separated_nonempty_list(COMMA,tyfield) -> tyfield . COMMA separated_nonempty_list(COMMA,tyfield) [ RPAREN RBRACE ]
##
## The known suffix of the stack is as follows:
## tyfield
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN ID COLON WHILE
##
## Ends in an error in state: 108.
##
## tyfield -> ID COLON . ID [ RPAREN RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## ID COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN ID WHILE
##
## Ends in an error in state: 107.
##
## tyfield -> ID . COLON ID [ RPAREN RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN RPAREN COLON ID WHILE
##
## Ends in an error in state: 131.
##
## fundec -> ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt) . EQ entryexpr [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN RPAREN COLON WHILE
##
## Ends in an error in state: 128.
##
## resultopt -> COLON . ID [ EQ ]
##
## The known suffix of the stack is as follows:
## COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN RPAREN EQ ID WHILE
##
## Ends in an error in state: 135.
##
## nonempty_list(fundec) -> fundec . [ VAR TYPE IN FUNCTION ]
## nonempty_list(fundec) -> fundec . nonempty_list(fundec) [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## fundec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 15, spurious reduction of production lvalue -> ID
## In state 21, spurious reduction of production expr -> lvalue
## In state 72, spurious reduction of production closedexpr -> expr
## In state 74, spurious reduction of production entryexpr -> closedexpr
## In state 133, spurious reduction of production fundec -> ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt) EQ entryexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN RPAREN EQ VAR
##
## Ends in an error in state: 132.
##
## fundec -> ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt) EQ . entryexpr [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt) EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN RPAREN WHILE
##
## Ends in an error in state: 127.
##
## fundec -> ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN . option(resultopt) EQ entryexpr [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN WHILE
##
## Ends in an error in state: 125.
##
## fundec -> ID LPAREN . loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt) EQ entryexpr [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID WHILE
##
## Ends in an error in state: 124.
##
## fundec -> ID . LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt) EQ entryexpr [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION WHILE
##
## Ends in an error in state: 123.
##
## fundecs -> FUNCTION . nonempty_list(fundec) [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## FUNCTION
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET IN STRING RPAREN
##
## Ends in an error in state: 143.
##
## list(exprseq) -> exprseq . list(exprseq) [ END ]
##
## The known suffix of the stack is as follows:
## exprseq
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 72, spurious reduction of production closedexpr -> expr
## In state 74, spurious reduction of production entryexpr -> closedexpr
## In state 145, spurious reduction of production exprseq -> entryexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET IN VAR
##
## Ends in an error in state: 140.
##
## expr -> LET list(dec) IN . list(exprseq) END [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## LET list(dec) IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID EQ ARRAY OF WHILE
##
## Ends in an error in state: 118.
##
## tydec -> ID EQ ARRAY OF . ID [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID EQ ARRAY OF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID EQ ARRAY WHILE
##
## Ends in an error in state: 117.
##
## tydec -> ID EQ ARRAY . OF ID [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID EQ ARRAY
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID EQ ID WHILE
##
## Ends in an error in state: 120.
##
## nonempty_list(tydec) -> tydec . [ VAR TYPE IN FUNCTION ]
## nonempty_list(tydec) -> tydec . nonempty_list(tydec) [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## tydec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID EQ LBRACE ID COLON ID RPAREN
##
## Ends in an error in state: 114.
##
## tydec -> ID EQ LBRACE loption(separated_nonempty_list(COMMA,tyfield)) . RBRACE [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID EQ LBRACE loption(separated_nonempty_list(COMMA,tyfield))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 110, spurious reduction of production separated_nonempty_list(COMMA,tyfield) -> tyfield
## In state 113, spurious reduction of production loption(separated_nonempty_list(COMMA,tyfield)) -> separated_nonempty_list(COMMA,tyfield)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID EQ LBRACE WHILE
##
## Ends in an error in state: 106.
##
## tydec -> ID EQ LBRACE . loption(separated_nonempty_list(COMMA,tyfield)) RBRACE [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID EQ LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID EQ WHILE
##
## Ends in an error in state: 105.
##
## tydec -> ID EQ . ID [ VAR TYPE IN ID FUNCTION ]
## tydec -> ID EQ . ARRAY OF ID [ VAR TYPE IN ID FUNCTION ]
## tydec -> ID EQ . LBRACE loption(separated_nonempty_list(COMMA,tyfield)) RBRACE [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID WHILE
##
## Ends in an error in state: 104.
##
## tydec -> ID . EQ ID [ VAR TYPE IN ID FUNCTION ]
## tydec -> ID . EQ ARRAY OF ID [ VAR TYPE IN ID FUNCTION ]
## tydec -> ID . EQ LBRACE loption(separated_nonempty_list(COMMA,tyfield)) RBRACE [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE WHILE
##
## Ends in an error in state: 103.
##
## tydecs -> TYPE . nonempty_list(tydec) [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## TYPE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID ASSIGN ID LBRACK STRING RBRACK OF STRING WHILE
##
## Ends in an error in state: 101.
##
## binop -> expr . EQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . NEQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . TIMES expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . MINUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . PLUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . GT expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## expr -> expr . AND expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## expr -> expr . OR expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## vardec -> VAR ID ASSIGN ID LBRACK expr RBRACK OF expr . [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID ASSIGN ID LBRACK expr RBRACK OF expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID ASSIGN ID LBRACK STRING RBRACK OF VAR
##
## Ends in an error in state: 100.
##
## vardec -> VAR ID ASSIGN ID LBRACK expr RBRACK OF . expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID ASSIGN ID LBRACK expr RBRACK OF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID ASSIGN ID LBRACK STRING RBRACK WHILE
##
## Ends in an error in state: 99.
##
## vardec -> VAR ID ASSIGN ID LBRACK expr RBRACK . OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID ASSIGN ID LBRACK expr RBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID ASSIGN ID LBRACK STRING WHILE
##
## Ends in an error in state: 98.
##
## binop -> expr . EQ expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . NEQ expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . TIMES expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . MINUS expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . PLUS expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . GT expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . AND expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . OR expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## vardec -> VAR ID ASSIGN ID LBRACK expr . RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID ASSIGN ID LBRACK expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID ASSIGN ID LBRACK VAR
##
## Ends in an error in state: 97.
##
## vardec -> VAR ID ASSIGN ID LBRACK . expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID ASSIGN ID LBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID ASSIGN ID WHILE
##
## Ends in an error in state: 96.
##
## expr -> ID . LBRACE list(fields) RBRACE [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## expr -> ID . LPAREN list(exprlist) RPAREN [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## lvalue -> ID . [ VAR TYPE TIMES PLUS OR NEQ MINUS LBRACK IN GT FUNCTION EQ DOT ASSIGN AND ]
## vardec -> VAR ID ASSIGN ID . LBRACK expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID ASSIGN ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID ASSIGN STRING WHILE
##
## Ends in an error in state: 102.
##
## binop -> expr . EQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . NEQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . TIMES expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . MINUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . PLUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . GT expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## expr -> expr . AND expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## expr -> expr . OR expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## vardec -> VAR ID ASSIGN expr . [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID ASSIGN expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID ASSIGN VAR
##
## Ends in an error in state: 95.
##
## vardec -> VAR ID ASSIGN . expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR ID ASSIGN . ID LBRACK expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID ASSIGN ID LBRACK STRING RBRACK OF STRING WHILE
##
## Ends in an error in state: 93.
##
## binop -> expr . EQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . NEQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . TIMES expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . MINUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . PLUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . GT expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## expr -> expr . AND expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## expr -> expr . OR expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## vardec -> VAR ID COLON ID ASSIGN ID LBRACK expr RBRACK OF expr . [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID ASSIGN ID LBRACK expr RBRACK OF expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID ASSIGN ID LBRACK STRING RBRACK OF VAR
##
## Ends in an error in state: 92.
##
## vardec -> VAR ID COLON ID ASSIGN ID LBRACK expr RBRACK OF . expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID ASSIGN ID LBRACK expr RBRACK OF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID ASSIGN ID LBRACK STRING RBRACK WHILE
##
## Ends in an error in state: 91.
##
## vardec -> VAR ID COLON ID ASSIGN ID LBRACK expr RBRACK . OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID ASSIGN ID LBRACK expr RBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID ASSIGN ID LBRACK STRING WHILE
##
## Ends in an error in state: 90.
##
## binop -> expr . EQ expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . NEQ expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . TIMES expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . MINUS expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . PLUS expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## binop -> expr . GT expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . AND expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## expr -> expr . OR expr [ TIMES RBRACK PLUS OR NEQ MINUS GT EQ AND ]
## vardec -> VAR ID COLON ID ASSIGN ID LBRACK expr . RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID ASSIGN ID LBRACK expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID ASSIGN ID LBRACK VAR
##
## Ends in an error in state: 89.
##
## vardec -> VAR ID COLON ID ASSIGN ID LBRACK . expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID ASSIGN ID LBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID ASSIGN ID WHILE
##
## Ends in an error in state: 12.
##
## expr -> ID . LBRACE list(fields) RBRACE [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## expr -> ID . LPAREN list(exprlist) RPAREN [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## lvalue -> ID . [ VAR TYPE TIMES PLUS OR NEQ MINUS LBRACK IN GT FUNCTION EQ DOT ASSIGN AND ]
## vardec -> VAR ID COLON ID ASSIGN ID . LBRACK expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID ASSIGN ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID ASSIGN STRING WHILE
##
## Ends in an error in state: 94.
##
## binop -> expr . EQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . NEQ expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . TIMES expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . MINUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . PLUS expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . GT expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## expr -> expr . AND expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## expr -> expr . OR expr [ VAR TYPE TIMES PLUS OR NEQ MINUS IN GT FUNCTION EQ AND ]
## vardec -> VAR ID COLON ID ASSIGN expr . [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID ASSIGN expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID ASSIGN VAR
##
## Ends in an error in state: 10.
##
## vardec -> VAR ID COLON ID ASSIGN . expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR ID COLON ID ASSIGN . ID LBRACK expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID WHILE
##
## Ends in an error in state: 9.
##
## vardec -> VAR ID COLON ID . ASSIGN expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR ID COLON ID . ASSIGN ID LBRACK expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON WHILE
##
## Ends in an error in state: 8.
##
## vardec -> VAR ID COLON . ID ASSIGN expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR ID COLON . ID ASSIGN ID LBRACK expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID WHILE
##
## Ends in an error in state: 7.
##
## vardec -> VAR ID . COLON ID ASSIGN expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR ID . COLON ID ASSIGN ID LBRACK expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR ID . ASSIGN expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR ID . ASSIGN ID LBRACK expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR WHILE
##
## Ends in an error in state: 6.
##
## vardec -> VAR . ID COLON ID ASSIGN expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR . ID COLON ID ASSIGN ID LBRACK expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR . ID ASSIGN expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR . ID ASSIGN ID LBRACK expr RBRACK OF expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET WHILE
##
## Ends in an error in state: 5.
##
## expr -> LET . list(dec) IN list(exprseq) END [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## LET
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LPAREN STRING END
##
## Ends in an error in state: 152.
##
## nonempty_list(exprseq) -> exprseq . [ RPAREN ]
## nonempty_list(exprseq) -> exprseq . nonempty_list(exprseq) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## exprseq
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 72, spurious reduction of production closedexpr -> expr
## In state 74, spurious reduction of production entryexpr -> closedexpr
## In state 145, spurious reduction of production exprseq -> entryexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LPAREN STRING VAR
##
## Ends in an error in state: 145.
##
## exprseq -> entryexpr . [ WHILE STRING RPAREN LPAREN LET INT IF ID FOR END ]
## exprseq -> entryexpr . SEMICOLON [ WHILE STRING RPAREN LPAREN LET INT IF ID FOR END ]
##
## The known suffix of the stack is as follows:
## entryexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 72, spurious reduction of production closedexpr -> expr
## In state 74, spurious reduction of production entryexpr -> closedexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LPAREN VAR
##
## Ends in an error in state: 3.
##
## expr -> LPAREN . RPAREN [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> LPAREN . nonempty_list(exprseq) RPAREN [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING AND STRING OF
##
## Ends in an error in state: 42.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr AND expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr AND expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING AND VAR
##
## Ends in an error in state: 41.
##
## expr -> expr AND . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr AND
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING EQ STRING OF
##
## Ends in an error in state: 40.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr EQ expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr EQ expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING EQ VAR
##
## Ends in an error in state: 39.
##
## binop -> expr EQ . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING GT STRING OF
##
## Ends in an error in state: 38.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr GT expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr GT expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING GT VAR
##
## Ends in an error in state: 37.
##
## binop -> expr GT . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr GT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING MINUS STRING OF
##
## Ends in an error in state: 36.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr MINUS expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr MINUS expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING MINUS VAR
##
## Ends in an error in state: 35.
##
## binop -> expr MINUS . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr MINUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING NEQ STRING OF
##
## Ends in an error in state: 34.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr NEQ expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr NEQ expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING NEQ VAR
##
## Ends in an error in state: 33.
##
## binop -> expr NEQ . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr NEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING OR STRING OF
##
## Ends in an error in state: 32.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr OR expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr OR expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING OR VAR
##
## Ends in an error in state: 31.
##
## expr -> expr OR . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr OR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING PLUS STRING OF
##
## Ends in an error in state: 30.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr PLUS expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr PLUS expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING PLUS VAR
##
## Ends in an error in state: 29.
##
## binop -> expr PLUS . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr PLUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING TIMES VAR
##
## Ends in an error in state: 24.
##
## binop -> expr TIMES . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr TIMES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING TO
##
## Ends in an error in state: 72.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## closedexpr -> expr . [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END ELSE COMMA ]
## expr -> expr . AND expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING WHILE
##
## Ends in an error in state: 159.
##
## prog -> entryexpr . EOF [ # ]
##
## The known suffix of the stack is as follows:
## entryexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 72, spurious reduction of production closedexpr -> expr
## In state 74, spurious reduction of production entryexpr -> closedexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: VAR
##
## Ends in an error in state: 0.
##
## prog' -> . prog [ # ]
##
## The known suffix of the stack is as follows:
##
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: WHILE STRING DO STRING OF
##
## Ends in an error in state: 156.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> expr . OR expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> WHILE expr DO expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## WHILE expr DO expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: WHILE STRING DO VAR
##
## Ends in an error in state: 155.
##
## expr -> WHILE expr DO . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## WHILE expr DO
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: WHILE STRING WHILE
##
## Ends in an error in state: 154.
##
## binop -> expr . EQ expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## binop -> expr . NEQ expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## binop -> expr . TIMES expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## binop -> expr . MINUS expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## binop -> expr . PLUS expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## binop -> expr . GT expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## expr -> expr . AND expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## expr -> expr . OR expr [ TIMES PLUS OR NEQ MINUS GT EQ DO AND ]
## expr -> WHILE expr . DO expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## WHILE expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: WHILE VAR
##
## Ends in an error in state: 1.
##
## expr -> WHILE . expr DO expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS OR NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## WHILE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

