prog: FOR ID ASSIGN STRING TO STRING DO VAR
##
## Ends in an error in state: 47.
##
## openexpr -> FOR ID ASSIGN expr TO expr DO . entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN expr TO expr DO
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FOR ID ASSIGN STRING TO STRING WHILE
##
## Ends in an error in state: 46.
##
## binop -> expr . EQ expr [ TIMES PLUS NEQ MINUS GT EQ DO AND ]
## binop -> expr . NEQ expr [ TIMES PLUS NEQ MINUS GT EQ DO AND ]
## binop -> expr . TIMES expr [ TIMES PLUS NEQ MINUS GT EQ DO AND ]
## binop -> expr . MINUS expr [ TIMES PLUS NEQ MINUS GT EQ DO AND ]
## binop -> expr . PLUS expr [ TIMES PLUS NEQ MINUS GT EQ DO AND ]
## binop -> expr . GT expr [ TIMES PLUS NEQ MINUS GT EQ DO AND ]
## binop -> expr . AND expr [ TIMES PLUS NEQ MINUS GT EQ DO AND ]
## openexpr -> FOR ID ASSIGN expr TO expr . DO entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN expr TO expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FOR ID ASSIGN STRING TO VAR
##
## Ends in an error in state: 45.
##
## openexpr -> FOR ID ASSIGN expr TO . expr DO entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN expr TO
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FOR ID ASSIGN STRING WHILE
##
## Ends in an error in state: 44.
##
## binop -> expr . EQ expr [ TO TIMES PLUS NEQ MINUS GT EQ AND ]
## binop -> expr . NEQ expr [ TO TIMES PLUS NEQ MINUS GT EQ AND ]
## binop -> expr . TIMES expr [ TO TIMES PLUS NEQ MINUS GT EQ AND ]
## binop -> expr . MINUS expr [ TO TIMES PLUS NEQ MINUS GT EQ AND ]
## binop -> expr . PLUS expr [ TO TIMES PLUS NEQ MINUS GT EQ AND ]
## binop -> expr . GT expr [ TO TIMES PLUS NEQ MINUS GT EQ AND ]
## binop -> expr . AND expr [ TO TIMES PLUS NEQ MINUS GT EQ AND ]
## openexpr -> FOR ID ASSIGN expr . TO expr DO entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FOR ID ASSIGN VAR
##
## Ends in an error in state: 17.
##
## openexpr -> FOR ID ASSIGN . expr TO expr DO entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR ID ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FOR ID WHILE
##
## Ends in an error in state: 16.
##
## openexpr -> FOR ID . ASSIGN expr TO expr DO entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: FOR WHILE
##
## Ends in an error in state: 15.
##
## openexpr -> FOR . ID ASSIGN expr TO expr DO entryexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## FOR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID ASSIGN STRING OF
##
## Ends in an error in state: 43.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> lvalue ASSIGN expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## lvalue ASSIGN expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID ASSIGN VAR
##
## Ends in an error in state: 42.
##
## expr -> lvalue ASSIGN . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## lvalue ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID DOT ID LBRACK ID RBRACK OF
##
## Ends in an error in state: 18.
##
## expr -> lvalue . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> lvalue . ASSIGN expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## lvalue -> lvalue . DOT lvalue [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## lvalue
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID DOT ID LBRACK STRING WHILE
##
## Ends in an error in state: 22.
##
## binop -> expr . EQ expr [ TIMES RBRACK PLUS NEQ MINUS GT EQ AND ]
## binop -> expr . NEQ expr [ TIMES RBRACK PLUS NEQ MINUS GT EQ AND ]
## binop -> expr . TIMES expr [ TIMES RBRACK PLUS NEQ MINUS GT EQ AND ]
## binop -> expr . MINUS expr [ TIMES RBRACK PLUS NEQ MINUS GT EQ AND ]
## binop -> expr . PLUS expr [ TIMES RBRACK PLUS NEQ MINUS GT EQ AND ]
## binop -> expr . GT expr [ TIMES RBRACK PLUS NEQ MINUS GT EQ AND ]
## binop -> expr . AND expr [ TIMES RBRACK PLUS NEQ MINUS GT EQ AND ]
## lvalue -> ID LBRACK expr . RBRACK [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## ID LBRACK expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID DOT ID LBRACK VAR
##
## Ends in an error in state: 21.
##
## lvalue -> ID LBRACK . expr RBRACK [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## ID LBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID DOT ID OF
##
## Ends in an error in state: 20.
##
## lvalue -> ID . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
## lvalue -> ID . LBRACK expr RBRACK [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID DOT WHILE
##
## Ends in an error in state: 19.
##
## lvalue -> lvalue DOT . lvalue [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## lvalue DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ ID COMMA WHILE
##
## Ends in an error in state: 77.
##
## list(fields) -> fields . list(fields) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## fields
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ STRING WHILE
##
## Ends in an error in state: 74.
##
## binop -> expr . EQ expr [ TIMES RBRACE PLUS NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . NEQ expr [ TIMES RBRACE PLUS NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . TIMES expr [ TIMES RBRACE PLUS NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . MINUS expr [ TIMES RBRACE PLUS NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . PLUS expr [ TIMES RBRACE PLUS NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . GT expr [ TIMES RBRACE PLUS NEQ MINUS ID GT EQ COMMA AND ]
## binop -> expr . AND expr [ TIMES RBRACE PLUS NEQ MINUS ID GT EQ COMMA AND ]
## field -> ID EQ expr . [ RBRACE ID COMMA ]
##
## The known suffix of the stack is as follows:
## ID EQ expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID EQ VAR
##
## Ends in an error in state: 73.
##
## field -> ID EQ . expr [ RBRACE ID COMMA ]
##
## The known suffix of the stack is as follows:
## ID EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE ID WHILE
##
## Ends in an error in state: 72.
##
## field -> ID . EQ expr [ RBRACE ID COMMA ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACE WHILE
##
## Ends in an error in state: 71.
##
## expr -> ID LBRACE . list(fields) RBRACE [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## ID LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACK STRING RBRACK LBRACK
##
## Ends in an error in state: 68.
##
## arrexp -> ID LBRACK expr RBRACK . OF expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## lvalue -> ID LBRACK expr RBRACK . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## ID LBRACK expr RBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACK STRING RBRACK OF STRING OF
##
## Ends in an error in state: 70.
##
## arrexp -> ID LBRACK expr RBRACK OF expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## ID LBRACK expr RBRACK OF expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACK STRING RBRACK OF VAR
##
## Ends in an error in state: 69.
##
## arrexp -> ID LBRACK expr RBRACK OF . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## ID LBRACK expr RBRACK OF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACK STRING WHILE
##
## Ends in an error in state: 67.
##
## arrexp -> ID LBRACK expr . RBRACK OF expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . EQ expr [ TIMES RBRACK PLUS NEQ MINUS GT EQ AND ]
## binop -> expr . NEQ expr [ TIMES RBRACK PLUS NEQ MINUS GT EQ AND ]
## binop -> expr . TIMES expr [ TIMES RBRACK PLUS NEQ MINUS GT EQ AND ]
## binop -> expr . MINUS expr [ TIMES RBRACK PLUS NEQ MINUS GT EQ AND ]
## binop -> expr . PLUS expr [ TIMES RBRACK PLUS NEQ MINUS GT EQ AND ]
## binop -> expr . GT expr [ TIMES RBRACK PLUS NEQ MINUS GT EQ AND ]
## binop -> expr . AND expr [ TIMES RBRACK PLUS NEQ MINUS GT EQ AND ]
## lvalue -> ID LBRACK expr . RBRACK [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## ID LBRACK expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LBRACK VAR
##
## Ends in an error in state: 66.
##
## arrexp -> ID LBRACK . expr RBRACK OF expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## lvalue -> ID LBRACK . expr RBRACK [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## ID LBRACK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LPAREN STRING COMMA VAR
##
## Ends in an error in state: 62.
##
## list(exprlist) -> exprlist . list(exprlist) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## exprlist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LPAREN STRING VAR
##
## Ends in an error in state: 64.
##
## exprlist -> entryexpr . [ WHILE STRING RPAREN LPAREN LET INT IF ID FOR ]
## exprlist -> entryexpr . COMMA [ WHILE STRING RPAREN LPAREN LET INT IF ID FOR ]
##
## The known suffix of the stack is as follows:
## entryexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 49, spurious reduction of production closedexpr -> expr
## In state 51, spurious reduction of production entryexpr -> closedexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID LPAREN VAR
##
## Ends in an error in state: 13.
##
## expr -> ID LPAREN . list(exprlist) RPAREN [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## ID LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: ID OF
##
## Ends in an error in state: 12.
##
## arrexp -> ID . LBRACK expr RBRACK OF expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> ID . LBRACE list(fields) RBRACE [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> ID . LPAREN list(exprlist) RPAREN [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## lvalue -> ID . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
## lvalue -> ID . LBRACK expr RBRACK [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DOT DO COMMA ASSIGN AND ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IF STRING THEN IF ID THEN ID ELSE ID WHILE
##
## Ends in an error in state: 56.
##
## closedexpr -> IF entryexpr THEN closedexpr . ELSE closedexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END ELSE COMMA ]
## openexpr -> IF entryexpr THEN closedexpr . ELSE openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## IF entryexpr THEN closedexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production lvalue -> ID
## In state 18, spurious reduction of production expr -> lvalue
## In state 49, spurious reduction of production closedexpr -> expr
## In state 59, spurious reduction of production closedexpr -> IF entryexpr THEN closedexpr ELSE closedexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IF STRING THEN STRING ELSE VAR
##
## Ends in an error in state: 57.
##
## closedexpr -> IF entryexpr THEN closedexpr ELSE . closedexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END ELSE COMMA ]
## openexpr -> IF entryexpr THEN closedexpr ELSE . openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## IF entryexpr THEN closedexpr ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IF STRING THEN STRING TO
##
## Ends in an error in state: 55.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . AND expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## closedexpr -> expr . [ ELSE ]
## openexpr -> IF entryexpr THEN expr . [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## IF entryexpr THEN expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IF STRING THEN VAR
##
## Ends in an error in state: 53.
##
## closedexpr -> IF entryexpr THEN . closedexpr ELSE closedexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END ELSE COMMA ]
## openexpr -> IF entryexpr THEN . expr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
## openexpr -> IF entryexpr THEN . openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
## openexpr -> IF entryexpr THEN . closedexpr ELSE openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## IF entryexpr THEN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IF STRING WHILE
##
## Ends in an error in state: 52.
##
## closedexpr -> IF entryexpr . THEN closedexpr ELSE closedexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END ELSE COMMA ]
## openexpr -> IF entryexpr . THEN expr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
## openexpr -> IF entryexpr . THEN openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
## openexpr -> IF entryexpr . THEN closedexpr ELSE openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## IF entryexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 49, spurious reduction of production closedexpr -> expr
## In state 51, spurious reduction of production entryexpr -> closedexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: IF VAR
##
## Ends in an error in state: 14.
##
## closedexpr -> IF . entryexpr THEN closedexpr ELSE closedexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END ELSE COMMA ]
## openexpr -> IF . entryexpr THEN expr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
## openexpr -> IF . entryexpr THEN openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
## openexpr -> IF . entryexpr THEN closedexpr ELSE openexpr [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END COMMA ]
##
## The known suffix of the stack is as follows:
## IF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN ID COLON ID COMMA WHILE
##
## Ends in an error in state: 92.
##
## separated_nonempty_list(COMMA,tyfield) -> tyfield COMMA . separated_nonempty_list(COMMA,tyfield) [ RPAREN RBRACE ]
##
## The known suffix of the stack is as follows:
## tyfield COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN ID COLON ID RBRACE
##
## Ends in an error in state: 107.
##
## fundec -> ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) . RPAREN option(resultopt) EQ entryexpr [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID LPAREN loption(separated_nonempty_list(COMMA,tyfield))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production separated_nonempty_list(COMMA,tyfield) -> tyfield
## In state 94, spurious reduction of production loption(separated_nonempty_list(COMMA,tyfield)) -> separated_nonempty_list(COMMA,tyfield)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN ID COLON ID WHILE
##
## Ends in an error in state: 91.
##
## separated_nonempty_list(COMMA,tyfield) -> tyfield . [ RPAREN RBRACE ]
## separated_nonempty_list(COMMA,tyfield) -> tyfield . COMMA separated_nonempty_list(COMMA,tyfield) [ RPAREN RBRACE ]
##
## The known suffix of the stack is as follows:
## tyfield
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN ID COLON WHILE
##
## Ends in an error in state: 89.
##
## tyfield -> ID COLON . ID [ RPAREN RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## ID COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN ID WHILE
##
## Ends in an error in state: 88.
##
## tyfield -> ID . COLON ID [ RPAREN RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN RPAREN COLON ID WHILE
##
## Ends in an error in state: 112.
##
## fundec -> ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt) . EQ entryexpr [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN RPAREN COLON WHILE
##
## Ends in an error in state: 109.
##
## resultopt -> COLON . ID [ EQ ]
##
## The known suffix of the stack is as follows:
## COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN RPAREN EQ ID WHILE
##
## Ends in an error in state: 116.
##
## nonempty_list(fundec) -> fundec . [ VAR TYPE IN FUNCTION ]
## nonempty_list(fundec) -> fundec . nonempty_list(fundec) [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## fundec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 12, spurious reduction of production lvalue -> ID
## In state 18, spurious reduction of production expr -> lvalue
## In state 49, spurious reduction of production closedexpr -> expr
## In state 51, spurious reduction of production entryexpr -> closedexpr
## In state 114, spurious reduction of production fundec -> ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt) EQ entryexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN RPAREN EQ VAR
##
## Ends in an error in state: 113.
##
## fundec -> ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt) EQ . entryexpr [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt) EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN RPAREN WHILE
##
## Ends in an error in state: 108.
##
## fundec -> ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN . option(resultopt) EQ entryexpr [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID LPAREN WHILE
##
## Ends in an error in state: 106.
##
## fundec -> ID LPAREN . loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt) EQ entryexpr [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION ID WHILE
##
## Ends in an error in state: 105.
##
## fundec -> ID . LPAREN loption(separated_nonempty_list(COMMA,tyfield)) RPAREN option(resultopt) EQ entryexpr [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET FUNCTION WHILE
##
## Ends in an error in state: 104.
##
## fundecs -> FUNCTION . nonempty_list(fundec) [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## FUNCTION
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET IN STRING RPAREN
##
## Ends in an error in state: 122.
##
## expr -> LET list(dec) IN nonempty_list(exprseq) . END [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## LET list(dec) IN nonempty_list(exprseq)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 49, spurious reduction of production closedexpr -> expr
## In state 51, spurious reduction of production entryexpr -> closedexpr
## In state 126, spurious reduction of production exprseq -> entryexpr
## In state 124, spurious reduction of production nonempty_list(exprseq) -> exprseq
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET IN VAR
##
## Ends in an error in state: 121.
##
## expr -> LET list(dec) IN . nonempty_list(exprseq) END [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## LET list(dec) IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID EQ ARRAY OF WHILE
##
## Ends in an error in state: 99.
##
## tydec -> ID EQ ARRAY OF . ID [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID EQ ARRAY OF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID EQ ARRAY WHILE
##
## Ends in an error in state: 98.
##
## tydec -> ID EQ ARRAY . OF ID [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID EQ ARRAY
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID EQ ID WHILE
##
## Ends in an error in state: 101.
##
## nonempty_list(tydec) -> tydec . [ VAR TYPE IN FUNCTION ]
## nonempty_list(tydec) -> tydec . nonempty_list(tydec) [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## tydec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID EQ LBRACE ID COLON ID RPAREN
##
## Ends in an error in state: 95.
##
## tydec -> ID EQ LBRACE loption(separated_nonempty_list(COMMA,tyfield)) . RBRACE [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID EQ LBRACE loption(separated_nonempty_list(COMMA,tyfield))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production separated_nonempty_list(COMMA,tyfield) -> tyfield
## In state 94, spurious reduction of production loption(separated_nonempty_list(COMMA,tyfield)) -> separated_nonempty_list(COMMA,tyfield)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID EQ LBRACE WHILE
##
## Ends in an error in state: 87.
##
## tydec -> ID EQ LBRACE . loption(separated_nonempty_list(COMMA,tyfield)) RBRACE [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID EQ LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID EQ WHILE
##
## Ends in an error in state: 86.
##
## tydec -> ID EQ . ID [ VAR TYPE IN ID FUNCTION ]
## tydec -> ID EQ . ARRAY OF ID [ VAR TYPE IN ID FUNCTION ]
## tydec -> ID EQ . LBRACE loption(separated_nonempty_list(COMMA,tyfield)) RBRACE [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE ID WHILE
##
## Ends in an error in state: 85.
##
## tydec -> ID . EQ ID [ VAR TYPE IN ID FUNCTION ]
## tydec -> ID . EQ ARRAY OF ID [ VAR TYPE IN ID FUNCTION ]
## tydec -> ID . EQ LBRACE loption(separated_nonempty_list(COMMA,tyfield)) RBRACE [ VAR TYPE IN ID FUNCTION ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET TYPE WHILE
##
## Ends in an error in state: 84.
##
## tydecs -> TYPE . nonempty_list(tydec) [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## TYPE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID ASSIGN STRING WHILE
##
## Ends in an error in state: 83.
##
## binop -> expr . EQ expr [ VAR TYPE TIMES PLUS NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . NEQ expr [ VAR TYPE TIMES PLUS NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . TIMES expr [ VAR TYPE TIMES PLUS NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . MINUS expr [ VAR TYPE TIMES PLUS NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . PLUS expr [ VAR TYPE TIMES PLUS NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . GT expr [ VAR TYPE TIMES PLUS NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . AND expr [ VAR TYPE TIMES PLUS NEQ MINUS IN GT FUNCTION EQ AND ]
## vardec -> VAR ID ASSIGN expr . [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID ASSIGN expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID ASSIGN VAR
##
## Ends in an error in state: 82.
##
## vardec -> VAR ID ASSIGN . expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID ASSIGN STRING WHILE
##
## Ends in an error in state: 81.
##
## binop -> expr . EQ expr [ VAR TYPE TIMES PLUS NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . NEQ expr [ VAR TYPE TIMES PLUS NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . TIMES expr [ VAR TYPE TIMES PLUS NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . MINUS expr [ VAR TYPE TIMES PLUS NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . PLUS expr [ VAR TYPE TIMES PLUS NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . GT expr [ VAR TYPE TIMES PLUS NEQ MINUS IN GT FUNCTION EQ AND ]
## binop -> expr . AND expr [ VAR TYPE TIMES PLUS NEQ MINUS IN GT FUNCTION EQ AND ]
## vardec -> VAR ID COLON ID ASSIGN expr . [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID ASSIGN expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID ASSIGN VAR
##
## Ends in an error in state: 10.
##
## vardec -> VAR ID COLON ID ASSIGN . expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON ID WHILE
##
## Ends in an error in state: 9.
##
## vardec -> VAR ID COLON ID . ASSIGN expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID COLON WHILE
##
## Ends in an error in state: 8.
##
## vardec -> VAR ID COLON . ID ASSIGN expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR ID WHILE
##
## Ends in an error in state: 7.
##
## vardec -> VAR ID . COLON ID ASSIGN expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR ID . ASSIGN expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET VAR WHILE
##
## Ends in an error in state: 6.
##
## vardec -> VAR . ID COLON ID ASSIGN expr [ VAR TYPE IN FUNCTION ]
## vardec -> VAR . ID ASSIGN expr [ VAR TYPE IN FUNCTION ]
##
## The known suffix of the stack is as follows:
## VAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LET WHILE
##
## Ends in an error in state: 5.
##
## expr -> LET . list(dec) IN nonempty_list(exprseq) END [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## LET
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LPAREN STRING END
##
## Ends in an error in state: 131.
##
## expr -> LPAREN nonempty_list(exprseq) . RPAREN [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## LPAREN nonempty_list(exprseq)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 49, spurious reduction of production closedexpr -> expr
## In state 51, spurious reduction of production entryexpr -> closedexpr
## In state 126, spurious reduction of production exprseq -> entryexpr
## In state 124, spurious reduction of production nonempty_list(exprseq) -> exprseq
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LPAREN STRING SEMICOLON VAR
##
## Ends in an error in state: 124.
##
## nonempty_list(exprseq) -> exprseq . [ RPAREN END ]
## nonempty_list(exprseq) -> exprseq . nonempty_list(exprseq) [ RPAREN END ]
##
## The known suffix of the stack is as follows:
## exprseq
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LPAREN STRING VAR
##
## Ends in an error in state: 126.
##
## exprseq -> entryexpr . [ WHILE STRING RPAREN LPAREN LET INT IF ID FOR END ]
## exprseq -> entryexpr . SEMICOLON [ WHILE STRING RPAREN LPAREN LET INT IF ID FOR END ]
##
## The known suffix of the stack is as follows:
## entryexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 49, spurious reduction of production closedexpr -> expr
## In state 51, spurious reduction of production entryexpr -> closedexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: LPAREN VAR
##
## Ends in an error in state: 3.
##
## expr -> LPAREN . RPAREN [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> LPAREN . nonempty_list(exprseq) RPAREN [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING AND STRING OF
##
## Ends in an error in state: 40.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr AND expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr AND expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING AND VAR
##
## Ends in an error in state: 39.
##
## binop -> expr AND . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr AND
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING EQ VAR
##
## Ends in an error in state: 37.
##
## binop -> expr EQ . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING GT VAR
##
## Ends in an error in state: 35.
##
## binop -> expr GT . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr GT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING MINUS VAR
##
## Ends in an error in state: 33.
##
## binop -> expr MINUS . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr MINUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING NEQ VAR
##
## Ends in an error in state: 31.
##
## binop -> expr NEQ . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr NEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING PLUS VAR
##
## Ends in an error in state: 29.
##
## binop -> expr PLUS . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr PLUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING TIMES VAR
##
## Ends in an error in state: 23.
##
## binop -> expr TIMES . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## expr TIMES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING TO
##
## Ends in an error in state: 49.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## binop -> expr . AND expr [ WHILE VAR TYPE TIMES THEN STRING SEMICOLON RPAREN PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE COMMA AND ]
## closedexpr -> expr . [ WHILE VAR TYPE THEN STRING SEMICOLON RPAREN LPAREN LET INT IN IF ID FUNCTION FOR EOF END ELSE COMMA ]
##
## The known suffix of the stack is as follows:
## expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: STRING WHILE
##
## Ends in an error in state: 138.
##
## prog -> entryexpr . EOF [ # ]
##
## The known suffix of the stack is as follows:
## entryexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 49, spurious reduction of production closedexpr -> expr
## In state 51, spurious reduction of production entryexpr -> closedexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: VAR
##
## Ends in an error in state: 0.
##
## prog' -> . prog [ # ]
##
## The known suffix of the stack is as follows:
##
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: WHILE STRING DO STRING OF
##
## Ends in an error in state: 135.
##
## binop -> expr . EQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . NEQ expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . TIMES expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . MINUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . PLUS expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . GT expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## binop -> expr . AND expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
## expr -> WHILE expr DO expr . [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## WHILE expr DO expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: WHILE STRING DO VAR
##
## Ends in an error in state: 134.
##
## expr -> WHILE expr DO . expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## WHILE expr DO
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: WHILE STRING WHILE
##
## Ends in an error in state: 133.
##
## binop -> expr . EQ expr [ TIMES PLUS NEQ MINUS GT EQ DO AND ]
## binop -> expr . NEQ expr [ TIMES PLUS NEQ MINUS GT EQ DO AND ]
## binop -> expr . TIMES expr [ TIMES PLUS NEQ MINUS GT EQ DO AND ]
## binop -> expr . MINUS expr [ TIMES PLUS NEQ MINUS GT EQ DO AND ]
## binop -> expr . PLUS expr [ TIMES PLUS NEQ MINUS GT EQ DO AND ]
## binop -> expr . GT expr [ TIMES PLUS NEQ MINUS GT EQ DO AND ]
## binop -> expr . AND expr [ TIMES PLUS NEQ MINUS GT EQ DO AND ]
## expr -> WHILE expr . DO expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## WHILE expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

prog: WHILE VAR
##
## Ends in an error in state: 1.
##
## expr -> WHILE . expr DO expr [ WHILE VAR TYPE TO TIMES THEN STRING SEMICOLON RPAREN RBRACK RBRACE PLUS NEQ MINUS LPAREN LET INT IN IF ID GT FUNCTION FOR EQ EOF END ELSE DO COMMA AND ]
##
## The known suffix of the stack is as follows:
## WHILE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

